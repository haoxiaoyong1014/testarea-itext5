package mkl.testarea.itext5.xmlworker;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;

import org.junit.BeforeClass;
import org.junit.Test;

import com.itextpdf.text.Chunk;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPTable;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.tool.xml.ElementList;
import com.itextpdf.tool.xml.XMLWorker;
import com.itextpdf.tool.xml.XMLWorkerFontProvider;
import com.itextpdf.tool.xml.css.StyleAttrCSSResolver;
import com.itextpdf.tool.xml.html.CssAppliers;
import com.itextpdf.tool.xml.html.CssAppliersImpl;
import com.itextpdf.tool.xml.html.Tags;
import com.itextpdf.tool.xml.parser.XMLParser;
import com.itextpdf.tool.xml.pipeline.css.CSSResolver;
import com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline;
import com.itextpdf.tool.xml.pipeline.end.ElementHandlerPipeline;
import com.itextpdf.tool.xml.pipeline.html.HtmlPipeline;
import com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext;

/**
 * @author mkl
 */
public class PageBreaks
{
    final static File RESULT_FOLDER = new File("target/test-outputs", "xmlworker");

    @BeforeClass
    public static void setUpBeforeClass() throws Exception
    {
        RESULT_FOLDER.mkdirs();
    }

    /**
     * <a href="http://stackoverflow.com/questions/42412002/xmlworker-itext-doesnt-break-page-in-pdf-result">
     * XMLWorker (iText) doesn't break page in PDF result
     * </a>
     * <br/>
     * <a href="http://developers.itextpdf.com/fr/node/2078#999-parsehtml7.java">
     * ParseHtml7 iText example
     * </a>
     * <p>
     * Indeed, the ParseHtml7 iText example does not respect page-break-before
     * style entries. The cause is that they are only supported when the elements
     * generated by the XML worker are directly added to the Document, not when
     * they are added to a table cell as in your example. Unfortunately RTL is
     * only supported inside table cells.
     * </p>
     * <p>
     * {@link #testParseHtml7Improved()} shows how to explicitly support the
     * page-break-before style entries by recognizing the {@link Chunk#NEWPAGE}
     * elements generated for page-break-before elements and creating a new page
     * then. 
     * </p>
     */
    @Test
    public void testParseHtml7Original() throws DocumentException, IOException
    {
        try (   InputStream resource = getClass().getResourceAsStream("PageBreaks.html")    )
        {
            // step 1
            Document document = new Document();
            // step 2
            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(new File(RESULT_FOLDER, "PageBreaks.pdf")));
            // step 3
            document.open();
            // step 4
            // Styles
            CSSResolver cssResolver = new StyleAttrCSSResolver();
            XMLWorkerFontProvider fontProvider = new XMLWorkerFontProvider(XMLWorkerFontProvider.DONTLOOKFORFONTS);
            fontProvider.register("src/test/resources/mkl/testarea/itext5/xmlworker/NotoNaskhArabic-Regular.ttf");
            CssAppliers cssAppliers = new CssAppliersImpl(fontProvider);
            // HTML
            HtmlPipelineContext htmlContext = new HtmlPipelineContext(cssAppliers);
            htmlContext.setTagFactory(Tags.getHtmlTagProcessorFactory());
            // Pipelines
            ElementList elements = new ElementList();
            ElementHandlerPipeline pdf = new ElementHandlerPipeline(elements, null);
            HtmlPipeline html = new HtmlPipeline(htmlContext, pdf);
            CssResolverPipeline css = new CssResolverPipeline(cssResolver, html);
     
            // XML Worker
            XMLWorker worker = new XMLWorker(css, true);
            XMLParser p = new XMLParser(worker);
            p.parse(resource, Charset.forName("UTF-8"));
     
            PdfPTable table = new PdfPTable(1);
            PdfPCell cell = new PdfPCell();
            cell.setRunDirection(PdfWriter.RUN_DIRECTION_RTL);
            for (Element e : elements) {
                cell.addElement(e);
            }
            table.addCell(cell);
            document.add(table);
            // step 5
            document.close();
        }
    }

    /**
     * <a href="http://stackoverflow.com/questions/42412002/xmlworker-itext-doesnt-break-page-in-pdf-result">
     * XMLWorker (iText) doesn't break page in PDF result
     * </a>
     * <br/>
     * <a href="http://developers.itextpdf.com/fr/node/2078#999-parsehtml7.java">
     * ParseHtml7 iText example
     * </a>
     * <p>
     * Indeed, the ParseHtml7 iText example does not respect page-break-before
     * style entries, cf. {@link #testParseHtml7Original()}. The cause is that
     * they are only supported when the elements generated by the XML worker
     * are directly added to the Document, not when they are added to a table
     * cell as in your example. Unfortunately RTL is only supported inside
     * table cells.
     * </p>
     * <p>
     * This test shows how to explicitly support the page-break-before style
     * entries by recognizing the {@link Chunk#NEWPAGE} elements generated for
     * page-break-before elements and creating a new page then. 
     * </p>
     */
    @Test
    public void testParseHtml7Improved() throws DocumentException, IOException
    {
        try (   InputStream resource = getClass().getResourceAsStream("PageBreaks.html")    )
        {
            // step 1
            Document document = new Document();
            // step 2
            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(new File(RESULT_FOLDER, "PageBreaks-improved.pdf")));
            // step 3
            document.open();
            // step 4
            // Styles
            CSSResolver cssResolver = new StyleAttrCSSResolver();
            XMLWorkerFontProvider fontProvider = new XMLWorkerFontProvider(XMLWorkerFontProvider.DONTLOOKFORFONTS);
            fontProvider.register("src/test/resources/mkl/testarea/itext5/xmlworker/NotoNaskhArabic-Regular.ttf");
            CssAppliers cssAppliers = new CssAppliersImpl(fontProvider);
            // HTML
            HtmlPipelineContext htmlContext = new HtmlPipelineContext(cssAppliers);
            htmlContext.setTagFactory(Tags.getHtmlTagProcessorFactory());
            // Pipelines
            ElementList elements = new ElementList();
            ElementHandlerPipeline pdf = new ElementHandlerPipeline(elements, null);
            HtmlPipeline html = new HtmlPipeline(htmlContext, pdf);
            CssResolverPipeline css = new CssResolverPipeline(cssResolver, html);
     
            // XML Worker
            XMLWorker worker = new XMLWorker(css, true);
            XMLParser p = new XMLParser(worker);
            p.parse(resource, Charset.forName("UTF-8"));
     
            PdfPTable table = new PdfPTable(1);
            PdfPCell cell = new PdfPCell();
            cell.setRunDirection(PdfWriter.RUN_DIRECTION_RTL);
            for (Element e : elements) {
                if (e == Chunk.NEXTPAGE)
                {
                    table.addCell(cell);
                    document.add(table);
                    document.newPage();
                    table = new PdfPTable(1);
                    cell = new PdfPCell();
                }
                else
                {
                    cell.addElement(e);
                }
            }
            table.addCell(cell);
            document.add(table);
            // step 5
            document.close();
        }
    }
}
